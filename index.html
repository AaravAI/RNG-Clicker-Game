<!doctype html>
<html>
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <title>RNG Clicker — Main + Event Box</title>
    <meta name="description" content="RNG Clicker — idle box-hatching clicker. Open Main & Event boxes, upgrade skins, rebirth for more equip slots, and let the Auto-Opener grind. Autosaves in your browser. Local username profiles." />
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      html,body,#root{height:100%;background:#08090b}
      *{box-sizing:border-box}
      .bg-grid{background-image:radial-gradient(rgba(255,255,255,.04) 1px,transparent 1px);background-size:24px 24px}
      .glass{backdrop-filter:blur(10px);background:rgba(16,16,20,.55)}
      .btn{transition:transform .06s ease,box-shadow .2s ease,opacity .2s ease;box-shadow:0 8px 24px rgba(0,0,0,.35),inset 0 0 0 1px rgba(255,255,255,.04)}
      .btn:active{transform:translateY(1px) scale(.995)}
      .btn-emerald{background:linear-gradient(180deg,#34d399,#059669)}
      .btn-sky{background:linear-gradient(180deg,#38bdf8,#0284c7)}
      .btn-rose{background:linear-gradient(180deg,#fb7185,#be123c)}
      .btn-fuchsia{background:linear-gradient(180deg,#e879f9,#a21caf)}
      .btn-amber{background:linear-gradient(180deg,#fbbf24,#b45309);color:#111827}
      .glow-common{box-shadow:0 0 24px 4px rgba(156,163,175,.25)}
      .glow-rare{box-shadow:0 0 24px 6px rgba(59,130,246,.28)}
      .glow-epic{box-shadow:0 0 28px 8px rgba(139,92,246,.32)}
      .glow-legendary{box-shadow:0 0 30px 10px rgba(245,158,11,.35)}
      .glow-mythic{box-shadow:0 0 34px 12px rgba(239,68,68,.40)}
      .glow-unique{box-shadow:0 0 44px 14px rgba(124,58,237,.45), 0 0 80px 26px rgba(255,255,255,.28)}
      .glow-impossible{box-shadow:0 0 40px 16px rgba(255,255,255,.45), 0 0 70px 24px rgba(168,85,247,.35)}
      .glow-event{box-shadow:0 0 36px 10px rgba(34,197,94,.35)}
      .glow-special{box-shadow:0 0 48px 16px rgba(14,165,233,.45), 0 0 84px 28px rgba(255,255,255,.25)}
      @keyframes floatUp{0%{transform:translateY(0) scale(1);opacity:1}70%{opacity:.9}100%{transform:translateY(-80px) scale(.96);opacity:0}}
      .particle{position:absolute;pointer-events:none;color:#faffff;font-weight:700;text-shadow:0 1px 0 rgba(0,0,0,.5);animation:floatUp 800ms ease forwards}
      .hero-gradient{background:radial-gradient(1200px 600px at 20% -20%, #1f2937 0%, transparent 60%),radial-gradient(1000px 500px at 120% 10%, #0ea5e9 0%, transparent 45%),radial-gradient(900px 600px at 50% 120%, #a78bfa 0%, transparent 45%),linear-gradient(180deg, #0b0f14 0%, #090a0e 100%)}
      @keyframes pop{0%{transform:scale(.9);opacity:0}60%{transform:scale(1.02);opacity:1}100%{transform:scale(1)}}
      .pop{animation:pop .35s ease both}
      .shine{background:linear-gradient(120deg,transparent 0%,rgba(255,255,255,.18) 30%,transparent 60%);background-size:200% 100%;animation:shine 2.2s ease-in-out infinite}
      @keyframes shine{0%{background-position:200% 0}100%{background-position:-200% 0}}
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel">
      const {useState,useEffect,useMemo} = React;

      /* ---------- utils ---------- */
      const UNITS=[
        {value:1e33,suffix:"Dc"},{value:1e30,suffix:"No"},{value:1e27,suffix:"Oc"},
        {value:1e24,suffix:"Sp"},{value:1e21,suffix:"Sx"},{value:1e18,suffix:"Qi"},
        {value:1e15,suffix:"Qa"},{value:1e12,suffix:"T"},{value:1e9,suffix:"B"},
        {value:1e6,suffix:"M"},{value:1e3,suffix:"k"},
      ];
      const clamp2=x=>Math.round(x*100)/100;
      function fmt(n){if(!isFinite(n))return"∞";const a=Math.abs(n);for(const u of UNITS)if(a>=u.value)return(n/u.value).toFixed(2).replace(/\.00$/,"")+u.suffix;return Math.floor(n).toString()}
      function toRoman(num){if(num<=0)return"";const R=[[1000,'M'],[900,'CM'],[500,'D'],[400,'CD'],[100,'C'],[90,'XC'],[50,'L'],[40,'XL'],[10,'X'],[9,'IX'],[5,'V'],[4,'IV'],[1,'I']];let s='';for(const[v,t]of R){while(num>=v){s+=t;num-=v}}return s}
      function rollWeighted(table){const total=table.reduce((a,t)=>a+t.chance,0);let r=Math.random()*total,acc=0;for(const item of table){acc+=item.chance;if(r<acc)return item.rarity}return table[table.length-1].rarity}
      function spawnParticle(e,txt){const p=document.createElement("div");p.className="particle";p.style.left=e.clientX+"px";p.style.top=e.clientY+"px";p.textContent=txt;document.body.appendChild(p);setTimeout(()=>p.remove(),900)}

      /* ---------- boxes & skin data ---------- */
      const MAIN_BOX={ cost:100,
        rng:[
          {rarity:"Common",chance:79.89899},
          {rarity:"Rare",chance:15},
          {rarity:"Epic",chance:4},
          {rarity:"Legendary",chance:1},
          {rarity:"Mythic",chance:0.1},
          {rarity:"Unique",chance:0.001},
          {rarity:"Impossible",chance:0.00001}
        ],
      };
      const EVENT_BOX={ cost:100, tokenCost:1000,
        rng:[
          {rarity:"Nothing",chance:98.99},
          {rarity:"Event",chance:1},            // +15
          {rarity:"Special Event",chance:0.01}, // +20
        ],
      };
      const SKIN={
        name:"Skin",
        basePpc:{Common:1,Rare:2,Epic:3,Legendary:4,Mythic:5,Unique:10,Impossible:30,"Event":15,"Special Event":20},
        gainPerLevel:{Common:1,Rare:2,Epic:3,Legendary:4,Mythic:5,Unique:10,Impossible:30,"Event":15,"Special Event":20},
        colors:{
          Common:"#9CA3AF",Rare:"#3B82F6",Epic:"#8B5CF6",Legendary:"#F59E0B",
          Mythic:"#EF4444",Unique:"#7C3AED",Impossible:"#FFFFFF",
          "Event":"#22c55e","Special Event":"#0ea5e9", Nothing:"#6b7280"
        },
      };
      const AUTO_DELETE_RARITIES=["Common","Rare","Epic","Legendary","Mythic"];

      /* ---------- local usernames (per-device profiles) ---------- */
      const LS_PREFIX="rng_clicker_";
      const KEY_USERS=LS_PREFIX+"users";
      const KEY_CURRENT=LS_PREFIX+"current";
      function keyForUser(u){return LS_PREFIX+"save_"+encodeURIComponent(u)}
      function listUsers(){try{const a=JSON.parse(localStorage.getItem(KEY_USERS)||"[]");return Array.isArray(a)?a:[]}catch{return[]}}
      function setUsers(a){try{localStorage.setItem(KEY_USERS,JSON.stringify(a))}catch{}}
      function getCurrentUser(){try{return localStorage.getItem(KEY_CURRENT)||""}catch{return""}}
      function setCurrentUser(u){try{localStorage.setItem(KEY_CURRENT,u||"")}catch{}}

      /* ---------- game state ---------- */
      const defaultState={
        points:0,totalClicks:0,
        autoClickerLevel:0,
        autoOpenerActive:false,
        autoOpenerLevel:0,            // boxes per batch = 1+level
        autoOpenerSpeedLevel:0,       // interval = 60/2^level (capped at 6)
        autoOpenerMode:"main",        // "main" or "event"
        autoOpenerStartedAt:0,
        lastSeen:Date.now(),
        lastAutoStopReason:"",
        inventory:[], invCap:100, invUpgrades:0,
        rebirths:0,
        eventTokens:0,
        showHelp:true,
        autoDelete:{Common:false,Rare:false,Epic:false,Legendary:false,Mythic:false},
      };
      function saveState(u,s){try{localStorage.setItem(keyForUser(u),JSON.stringify(s))}catch{}}
      function loadState(u){try{const raw=localStorage.getItem(keyForUser(u));if(raw)return {...defaultState,...JSON.parse(raw)}}catch{};return {...defaultState}}

      /* ---------- math ---------- */
      const skinUpgradeCost=level=>10**(level+2); // 100,1k,10k…
      const costAutoUpgrade=level=>10**(level+2);
      const costInvUpgrade=n=>10**(n+2);
      const costRebirth=n=>10**(n+2);
      const costAutoOpener=n=>10**(n+2);   // +1 per batch each level
      const costOpenerSpeed=n=>10**(n+3);  // 1k,10k,100k…
      const skinPpc=it=>SKIN.basePpc[it.rarity]+SKIN.gainPerLevel[it.rarity]*it.level;
      function equippedBest(inv,slots){
        const copies=[]; for(const it of inv){const p=skinPpc(it); for(let i=0;i<it.qty;i++) copies.push({rarity:it.rarity,level:it.level,ppc:p})}
        copies.sort((a,b)=>b.ppc-a.ppc);
        const chosen=copies.slice(0,Math.max(1,slots));
        const ppc=chosen.reduce((a,e)=>a+e.ppc,0);
        const label=chosen.map(e=>`${e.rarity} ${SKIN.name} (${toRoman(e.level)||'I'}) +${e.ppc}`).join(" + ");
        return {ppc,label};
      }
      const totalPpc=s=>1+equippedBest(s.inventory,s.rebirths+1).ppc;
      const autoIntervalSeconds=l=>60/Math.pow(2,Math.min(l,6));       // never pauses now
      const autoRatePerMin=l=>Math.pow(2,Math.min(l,6));
      const openerRate=l=>1+l;
      const openerIntervalSeconds=sl=>60/Math.pow(2,Math.min(sl,6));

      /* ---------- sign-in ---------- */
      function SignIn({onEnter}){
        const [u,setU]=useState("");
        const [users,setUsersState]=useState(listUsers());
        const [err,setErr]=useState("");
        function create(){
          const name=u.trim(); if(!name){setErr("Enter a username.");return}
          if(users.includes(name)){setErr("Username already exists on this device.");return}
          const next=[...users,name]; setUsers(next); setUsersState(next); setCurrentUser(name); onEnter(name,loadState(name));
        }
        function login(name){ setCurrentUser(name); onEnter(name,loadState(name)); }
        return (
          <div className="fixed inset-0 z-[60] hero-gradient bg-grid text-zinc-100 flex items-center justify-center">
            <div className="w-[560px] max-w-[92vw] rounded-3xl p-7 glass border border-zinc-700/60">
              <h2 className="text-3xl font-extrabold mb-2">RNG Clicker</h2>
              <p className="text-zinc-300 text-sm mb-4">Create a local username for this browser or sign in to one you used here before. (No passwords; data stays on this device.)</p>
              <div className="bg-zinc-900/60 border border-zinc-700 rounded-xl p-4">
                <div className="text-sm font-semibold mb-2">Sign up</div>
                <div className="flex gap-2">
                  <input className="w-full rounded-lg px-3 py-2 bg-zinc-800 border border-zinc-700 outline-none" placeholder="Choose a username" value={u} onChange={e=>setU(e.target.value)}/>
                  <button className="btn btn-emerald px-4 rounded-lg" onClick={create}>Create</button>
                </div>
                {err && <div className="text-rose-400 text-xs mt-2">{err}</div>}
              </div>
              <div className="mt-4 bg-zinc-900/60 border border-zinc-700 rounded-xl p-4">
                <div className="text-sm font-semibold mb-2">Sign in (this device)</div>
                {users.length===0 ? <div className="text-xs text-zinc-400">No users yet.</div> :
                  <div className="flex flex-wrap gap-2">
                    {users.map(name=>(
                      <button key={name} className="px-3 py-1.5 rounded-lg bg-zinc-800 hover:bg-zinc-700 border border-zinc-700 text-sm" onClick={()=>login(name)}>{name}</button>
                    ))}
                  </div>
                }
              </div>
            </div>
          </div>
        );
      }

      /* ---------- App ---------- */
      function App(){
        const [user,setUser]=useState(getCurrentUser());
        const [state,setState]=useState(user?loadState(user):null);
        const [hatchPopup,setHatchPopup]=useState(null);
        if(!user||!state) return <SignIn onEnter={(u,st)=>{setUser(u);setState(st);}}/>;

        // autosave
        useEffect(()=>{saveState(user,state)},[user,state]);
        useEffect(()=>{const id=setInterval(()=>saveState(user,state),5000);return()=>clearInterval(id)},[user,state]);
        useEffect(()=>{const h=()=>saveState(user,state);window.addEventListener("beforeunload",h);return()=>window.removeEventListener("beforeunload",h)},[user,state]);

        // offline catch-up: autoclicker DOES NOT pause
        useEffect(()=>{
          const now=Date.now();
          const elapsed=(now-state.lastSeen)/1000;
          if(elapsed<=1) return;
          let pts=state.points, inv=[...state.inventory], tokens=state.eventTokens;
          // autoclicker gain during offline time
          const acInterval=autoIntervalSeconds(state.autoClickerLevel);
          const gained=Math.floor(elapsed/acInterval);
          pts+=gained;

          if(state.autoOpenerActive){
            const rate=openerRate(state.autoOpenerLevel);
            const intv=openerIntervalSeconds(state.autoOpenerSpeedLevel);
            let ticks=Math.floor(elapsed/intv);
            let ops=ticks*rate;
            const added=[];
            while(ops-- > 0){
              const invCount=inv.reduce((a,i)=>a+i.qty,0);
              if(state.autoOpenerMode==="main"){
                if(pts<MAIN_BOX.cost || invCount>=state.invCap) break;
                pts-=MAIN_BOX.cost;
                const r=rollWeighted(MAIN_BOX.rng);
                if(state.autoDelete[r]){const refund=Math.floor(MAIN_BOX.cost*0.2); pts+=refund; added.push({rarity:r,autoDeleted:true,refund,box:"Main"});}
                else{const idx=inv.findIndex(it=>it.rarity===r); if(idx>=0) inv[idx]={...inv[idx],qty:inv[idx].qty+1}; else inv.push({rarity:r,level:0,qty:1}); added.push({rarity:r,autoDeleted:false,refund:0,box:"Main"});}
              }else{
                if(tokens<=0 || pts<EVENT_BOX.cost || invCount>=state.invCap) break;
                pts-=EVENT_BOX.cost; tokens-=1;
                const r=rollWeighted(EVENT_BOX.rng);
                if(r==="Nothing") added.push({rarity:"Nothing",autoDeleted:false,refund:0,box:"Event"});
                else{const idx=inv.findIndex(it=>it.rarity===r); if(idx>=0) inv[idx]={...inv[idx],qty:inv[idx].qty+1}; else inv.push({rarity:r,level:0,qty:1}); added.push({rarity:r,autoDeleted:false,refund:0,box:"Event"});}
              }
            }
            if(added.length) setHatchPopup({items:added,count:added.length});
          }
          setState(s=>({...s,points:pts,inventory:inv,eventTokens:tokens,lastSeen:now}));
        },[]);

        // online autoclicker (NEVER pauses)
        useEffect(()=>{
          let acc=0; const tick=100;
          const id=setInterval(()=>{
            setState(s=>{
              acc+=tick/1000;
              const interval=autoIntervalSeconds(s.autoClickerLevel);
              let gained=0; while(acc>=interval){gained++; acc-=interval;}
              if(gained===0) return s;
              return {...s,points:s.points+gained,lastSeen:Date.now()};
            });
          },tick);
          return()=>clearInterval(id);
        },[]);

        // online auto-opener
        useEffect(()=>{
          if(!state.autoOpenerActive) return;
          const ms=openerIntervalSeconds(state.autoOpenerSpeedLevel)*1000;
          const id=setInterval(()=>{
            setState(s=>{
              const rate=openerRate(s.autoOpenerLevel);
              let pts=s.points, inv=[...s.inventory], tokens=s.eventTokens;
              const results=[];
              for(let i=0;i<rate;i++){
                const invCount=inv.reduce((a,i)=>a+i.qty,0);
                if(invCount>=s.invCap) return {...s,autoOpenerActive:false,lastAutoStopReason:"Inventory full."};
                if(s.autoOpenerMode==="main"){
                  if(pts<MAIN_BOX.cost) return {...s,autoOpenerActive:false,lastAutoStopReason:"Not enough points."};
                  pts-=MAIN_BOX.cost;
                  const r=rollWeighted(MAIN_BOX.rng);
                  if(s.autoDelete[r]){const refund=Math.floor(MAIN_BOX.cost*0.2); pts+=refund; results.push({rarity:r,autoDeleted:true,refund,box:"Main"});}
                  else{const idx=inv.findIndex(it=>it.rarity===r); if(idx>=0) inv[idx]={...inv[idx],qty:inv[idx].qty+1}; else inv.push({rarity:r,level:0,qty:1}); results.push({rarity:r,autoDeleted:false,refund:0,box:"Main"});}
                }else{
                  if(tokens<=0 || pts<EVENT_BOX.cost) return {...s,autoOpenerActive:false,lastAutoStopReason:"No tokens / points."};
                  pts-=EVENT_BOX.cost; tokens-=1;
                  const r=rollWeighted(EVENT_BOX.rng);
                  if(r==="Nothing") results.push({rarity:"Nothing",autoDeleted:false,refund:0,box:"Event"});
                  else{const idx=inv.findIndex(it=>it.rarity===r); if(idx>=0) inv[idx]={...inv[idx],qty:inv[idx].qty+1}; else inv.push({rarity:r,level:0,qty:1}); results.push({rarity:r,autoDeleted:false,refund:0,box:"Event"});}
                }
              }
              if(results.length) setHatchPopup({items:results,count:results.length});
              return {...s,points:pts,inventory:inv,eventTokens:tokens,lastSeen:Date.now()};
            });
          },ms);
          return()=>clearInterval(id);
        },[state.autoOpenerActive,state.autoOpenerLevel,state.autoOpenerSpeedLevel,state.autoOpenerMode]);

        // helpers
        const openMain=()=>{
          setState(s=>{
            const invCount=s.inventory.reduce((a,i)=>a+i.qty,0);
            if(s.points<MAIN_BOX.cost || invCount>=s.invCap) return s;
            let pts=s.points-MAIN_BOX.cost;
            const rarity=rollWeighted(MAIN_BOX.rng);
            if(s.autoDelete[rarity]){
              const refund=Math.floor(MAIN_BOX.cost*0.2); pts+=refund;
              setHatchPopup({items:[{rarity,autoDeleted:true,refund,box:"Main"}],count:1});
              return {...s,points:pts};
            }else{
              const inv=[...s.inventory];
              const idx=inv.findIndex(i=>i.rarity===rarity);
              if(idx>=0) inv[idx]={...inv[idx],qty:inv[idx].qty+1}; else inv.push({rarity,level:0,qty:1});
              setHatchPopup({items:[{rarity,autoDeleted:false,refund:0,box:"Main"}],count:1});
              return {...s,points:pts,inventory:inv};
            }
          });
        };
        const openEvent=()=>{
          setState(s=>{
            const invCount=s.inventory.reduce((a,i)=>a+i.qty,0);
            if(s.eventTokens<=0 || s.points<EVENT_BOX.cost || invCount>=s.invCap) return s;
            let pts=s.points-EVENT_BOX.cost; let tokens=s.eventTokens-1;
            const rarity=rollWeighted(EVENT_BOX.rng);
            if(rarity==="Nothing"){
              setHatchPopup({items:[{rarity:"Nothing",autoDeleted:false,refund:0,box:"Event"}],count:1});
              return {...s,points:pts,eventTokens:tokens};
            }else{
              const inv=[...s.inventory];
              const idx=inv.findIndex(i=>i.rarity===rarity);
              if(idx>=0) inv[idx]={...inv[idx],qty:inv[idx].qty+1}; else inv.push({rarity,level:0,qty:1});
              setHatchPopup({items:[{rarity,autoDeleted:false,refund:0,box:"Event"}],count:1});
              return {...s,points:pts,eventTokens:tokens,inventory:inv};
            }
          });
        };
        const buyToken=()=>setState(s=>s.points>=EVENT_BOX.tokenCost?{...s,points:s.points-EVENT_BOX.tokenCost,eventTokens:s.eventTokens+1}:s);
        const upgradeAuto=()=>setState(s=> (s.autoClickerLevel>=6||s.points<costAutoUpgrade(s.autoClickerLevel))?s:{...s,points:s.points-costAutoUpgrade(s.autoClickerLevel),autoClickerLevel:s.autoClickerLevel+1});
        const upgradeRate=()=>setState(s=> s.points<costAutoOpener(s.autoOpenerLevel)?s:{...s,points:s.points-costAutoOpener(s.autoOpenerLevel),autoOpenerLevel:s.autoOpenerLevel+1});
        const upgradeSpeed=()=>setState(s=> (s.autoOpenerSpeedLevel>=6||s.points<costOpenerSpeed(s.autoOpenerSpeedLevel))?s:{...s,points:s.points-costOpenerSpeed(s.autoOpenerSpeedLevel),autoOpenerSpeedLevel:s.autoOpenerSpeedLevel+1});
        const expandInv=()=>setState(s=> s.points<costInvUpgrade(s.invUpgrades)?s:{...s,points:s.points-costInvUpgrade(s.invUpgrades),invCap:s.invCap+20,invUpgrades:s.invUpgrades+1});
        const rebirth=()=>setState(s=> s.points<costRebirth(s.rebirths)?s:{...s,points:0,rebirths:s.rebirths+1});

        return (
          <div className="w-screen h-screen text-zinc-100 overflow-hidden select-none">
            {/* top bar */}
            <div className="fixed top-0 inset-x-0 p-2 flex items-center justify-between bg-zinc-950/70 backdrop-blur border-b border-zinc-800 z-40">
              <div className="flex items-center gap-2">
                <div className="text-xs text-zinc-400">Signed in as <b>{user}</b></div>
                <div className="flex items-center gap-1 bg-zinc-800/70 border border-zinc-700 rounded-lg px-2 py-1">
                  <span className="text-xs text-zinc-300">Auto-Opener mode:</span>
                  <label className="text-xs flex items-center gap-1">
                    <input type="radio" name="mode" checked={state.autoOpenerMode==='main'} onChange={()=>setState(s=>({...s,autoOpenerMode:'main'}))}/> Main
                  </label>
                  <label className="text-xs flex items-center gap-1">
                    <input type="radio" name="mode" checked={state.autoOpenerMode==='event'} onChange={()=>setState(s=>({...s,autoOpenerMode:'event'}))}/> Event
                  </label>
                </div>
                <button className={`btn px-3 py-1.5 rounded-lg text-sm ${state.autoOpenerActive? "btn-amber":"btn-emerald"}`}
                        onClick={()=>!state.autoOpenerActive && setState(s=>({...s,autoOpenerActive:true,autoOpenerStartedAt:Date.now(),lastAutoStopReason:""}))}>
                  {state.autoOpenerActive ? "Auto-Opener running…" : "Start Auto-Opener"}
                </button>
                <span className="text-xs text-zinc-400">Stop: CTRL+5 (browser shortcut not needed anymore; stop by switching off with code edit if you want)</span>
              </div>
              <div className="flex items-center gap-3 text-xs text-zinc-300">
                <span>PPC: <b>{totalPpc(state)}</b></span>
                <span>• Auto: every {clamp2(autoIntervalSeconds(state.autoClickerLevel))}s (≈ {autoRatePerMin(state.autoClickerLevel)}/min)</span>
                <span>• Opener: {openerRate(state.autoOpenerLevel)} per batch / every {clamp2(openerIntervalSeconds(state.autoOpenerSpeedLevel))}s ({state.autoOpenerMode})</span>
                <span>• Tokens: {state.eventTokens}</span>
                <span>• Rebirths: {state.rebirths}</span>
                <span>• Inv: {state.inventory.reduce((a,i)=>a+i.qty,0)}/{state.invCap}</span>
                <span>• Points: <b>{fmt(state.points)}</b></span>
              </div>
            </div>

            {/* layout */}
            <div className="pt-14 grid grid-cols-5 gap-4 h-full p-4">
              {/* click zone */}
              <div className="col-span-3">
                <div className="relative w-full h-full bg-zinc-800/70 rounded-2xl shadow-inner border border-zinc-700 overflow-hidden"
                     onClick={(e)=>{ setState(s=>({ ...s, points: s.points + totalPpc(s), totalClicks: s.totalClicks + 1 })); spawnParticle(e, `+${totalPpc(state)}`); }}>
                  <div className="relative h-full flex items-center justify-center">
                    <div className="text-center">
                      <div className="text-6xl font-extrabold drop-shadow">{fmt(state.points)}</div>
                      <div className="text-zinc-400 mt-2">points</div>
                      <div className="mt-6 text-2xl">Click anywhere in this box (+{totalPpc(state)} per click)</div>
                      <div className="mt-2 text-zinc-400">Equipped: {equippedBest(state.inventory,state.rebirths+1).label || "None"}</div>
                    </div>
                  </div>
                </div>
              </div>

              {/* right panel */}
              <div className="col-span-2 h-full min-h-0">
                <div className="h-full overflow-y-auto pr-2 flex flex-col gap-4">

                  <div className="rounded-2xl p-4 border border-zinc-700 bg-zinc-900/60">
                    <div className="text-xl font-semibold">Open Boxes</div>
                    <div className="mt-2 flex items-center justify-between rounded-xl p-3 bg-zinc-950/60 border border-zinc-800">
                      <div>
                        <div className="font-medium">Main Box</div>
                        <div className="text-sm text-zinc-400">Cost: {fmt(MAIN_BOX.cost)}</div>
                      </div>
                      <button className={`btn px-3 py-2 rounded-lg text-sm ${(state.points>=MAIN_BOX.cost && state.inventory.reduce((a,i)=>a+i.qty,0)<state.invCap) ? "btn-emerald" : "bg-zinc-700 cursor-not-allowed"}`} onClick={openMain}>Open</button>
                    </div>

                    <div className="mt-2 flex items-center justify-between rounded-xl p-3 bg-zinc-950/60 border border-zinc-800">
                      <div>
                        <div className="font-medium">Event Box</div>
                        <div className="text-sm text-zinc-400">Cost: {fmt(EVENT_BOX.cost)} + 1 token • Tokens: <b>{state.eventTokens}</b></div>
                      </div>
                      <div className="flex gap-2">
                        <button className={`btn px-3 py-2 rounded-lg text-sm ${(state.points>=EVENT_BOX.cost && state.eventTokens>0 && state.inventory.reduce((a,i)=>a+i.qty,0)<state.invCap) ? "btn-amber" : "bg-zinc-700 cursor-not-allowed"}`} onClick={openEvent}>Open</button>
                        <button className={`btn px-3 py-2 rounded-lg text-sm ${state.points>=EVENT_BOX.tokenCost ? "btn-sky" : "bg-zinc-700 cursor-not-allowed"}`} onClick={buyToken}>Buy Token ({fmt(EVENT_BOX.tokenCost)})</button>
                      </div>
                    </div>
                  </div>

                  <div className="rounded-2xl p-4 border border-zinc-700 bg-zinc-900/60">
                    <div className="text-xl font-semibold">Upgrades</div>

                    <div className="mt-3 flex items-center justify-between rounded-xl p-3 bg-zinc-950/60 border border-zinc-800">
                      <div>
                        <div className="font-medium">Autoclicker Lv {state.autoClickerLevel} {state.autoClickerLevel>=6 && "(MAX)"}</div>
                        <div className="text-xs text-zinc-400">Every {clamp2(autoIntervalSeconds(state.autoClickerLevel))}s (≈ {autoRatePerMin(state.autoClickerLevel)}/min) — never pauses.</div>
                      </div>
                      <button className={`btn px-3 py-2 rounded-lg text-sm ${
                        state.autoClickerLevel>=6 ? "bg-zinc-700 cursor-not-allowed" :
                        (state.points>=costAutoUpgrade(state.autoClickerLevel) ? "btn-fuchsia" : "bg-zinc-700 cursor-not-allowed")
                      }`} onClick={upgradeAuto}>
                        {state.autoClickerLevel>=6 ? "Max" : `Upgrade (${fmt(costAutoUpgrade(state.autoClickerLevel))})`}
                      </button>
                    </div>

                    <div className="mt-3 flex items-center justify-between rounded-xl p-3 bg-zinc-950/60 border border-zinc-800">
                      <div>
                        <div className="font-medium">Auto-Opener Rate Lv {state.autoOpenerLevel} — {1+state.autoOpenerLevel} per batch ({state.autoOpenerMode})</div>
                      </div>
                      <button className={`btn px-3 py-2 rounded-lg text-sm ${state.points>=costAutoOpener(state.autoOpenerLevel) ? "btn-emerald" : "bg-zinc-700 cursor-not-allowed"}`} onClick={upgradeRate}>
                        Upgrade ({fmt(costAutoOpener(state.autoOpenerLevel))})
                      </button>
                    </div>

                    <div className="mt-3 flex items-center justify-between rounded-xl p-3 bg-zinc-950/60 border border-zinc-800">
                      <div>
                        <div className="font-medium">Auto-Opener Speed Lv {state.autoOpenerSpeedLevel} {state.autoOpenerSpeedLevel>=6 && "(MAX)"}</div>
                        <div className="text-xs text-zinc-400">Batch every {clamp2(openerIntervalSeconds(state.autoOpenerSpeedLevel))}s (60 → 30 → 15 → …)</div>
                      </div>
                      <button className={`btn px-3 py-2 rounded-lg text-sm ${
                        state.autoOpenerSpeedLevel>=6 ? "bg-zinc-700 cursor-not-allowed" :
                        (state.points>=costOpenerSpeed(state.autoOpenerSpeedLevel) ? "btn-amber" : "bg-zinc-700 cursor-not-allowed")
                      }`} onClick={upgradeSpeed}>
                        {state.autoOpenerSpeedLevel>=6 ? "Max" : `Upgrade (${fmt(costOpenerSpeed(state.autoOpenerSpeedLevel))})`}
                      </button>
                    </div>

                    <div className="mt-3 flex items-center justify-between rounded-xl p-3 bg-zinc-950/60 border border-zinc-800">
                      <div>
                        <div className="font-medium">Expand Inventory</div>
                        <div className="text-xs text-zinc-400">+20 slots • Next cost {fmt(costInvUpgrade(state.invUpgrades))}</div>
                      </div>
                      <button className={`btn px-3 py-2 rounded-lg text-sm ${state.points>=costInvUpgrade(state.invUpgrades) ? "btn-sky" : "bg-zinc-700 cursor-not-allowed"}`} onClick={expandInv}>Buy</button>
                    </div>

                    <div className="mt-3 flex items-center justify-between rounded-xl p-3 bg-zinc-950/60 border border-zinc-800">
                      <div>
                        <div className="font-medium">Rebirth</div>
                        <div className="text-xs text-zinc-400">Next cost: {fmt(costRebirth(state.rebirths))} • Equip slots: {state.rebirths + 1}</div>
                      </div>
                      <button className={`btn px-3 py-2 rounded-lg text-sm ${state.points>=costRebirth(state.rebirths) ? "btn-rose" : "bg-zinc-700 cursor-not-allowed"}`} onClick={rebirth}>+1 Equip</button>
                    </div>
                  </div>

                  <div className="rounded-2xl p-4 border border-zinc-700 bg-zinc-900/60">
                    <div className="flex items-center justify-between">
                      <div className="text-xl font-semibold">Inventory</div>
                      <details className="text-sm">
                        <summary className="cursor-pointer text-zinc-300">Auto-Delete</summary>
                        <div className="mt-2 grid grid-cols-5 gap-2 text-xs">
                          {AUTO_DELETE_RARITIES.map(r => (
                            <label key={r} className="flex items-center gap-1 bg-zinc-950/60 border border-zinc-800 rounded-md px-2 py-1">
                              <input type="checkbox" onChange={e=>setState(s=>({...s,autoDelete:{...s.autoDelete,[r]:e.target.checked}}))} checked={!!state.autoDelete[r]} />
                              <span>{r}</span>
                            </label>
                          ))}
                        </div>
                        <div className="mt-1 text-[11px] text-zinc-400">Refunds 20% of Main Box cost on fresh drops only.</div>
                      </details>
                    </div>
                    <div className="mt-2 grid grid-cols-1 gap-2">
                      {state.inventory.length===0 && (<div className="text-zinc-400 text-sm">No skins yet. Open boxes!</div>)}
                      {state.inventory.map(it=>{
                        const nextCost=skinUpgradeCost(it.level);
                        return (
                          <div key={it.rarity} className="flex items-center justify-between rounded-xl p-3 bg-zinc-950/60 border border-zinc-800">
                            <div>
                              <div className="font-medium">{it.rarity} {SKIN.name} <span className="opacity-70">{toRoman(it.level)||'I'}</span></div>
                              <div className="text-xs text-zinc-300">+{skinPpc(it)} PPC • Copies {it.qty}</div>
                            </div>
                            <button className={`btn px-3 py-2 rounded-lg text-sm ${state.points>=nextCost ? "btn-sky" : "bg-zinc-700 cursor-not-allowed"}`} onClick={()=>{
                              setState(s=>{
                                if(s.points<nextCost) return s;
                                const inv=[...s.inventory];
                                const idx=inv.findIndex(x=>x.rarity===it.rarity); if(idx<0) return s;
                                inv[idx]={...inv[idx],level:inv[idx].level+1};
                                return {...s,points:s.points-nextCost,inventory:inv};
                              });
                            }}>Upgrade ({fmt(nextCost)})</button>
                          </div>
                        );
                      })}
                    </div>
                  </div>

                </div>
              </div>
            </div>

            {/* Hatch popup */}
            {hatchPopup && (
              <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/70" onClick={()=>setHatchPopup(null)}>
                <div className="relative w-[560px] max-height-[70vh] overflow-y-auto border border-zinc-700 rounded-2xl bg-zinc-900 p-4 pop">
                  <div className="text-sm text-zinc-300">Opened {hatchPopup.count} {hatchPopup.count>1?"boxes":"box"}</div>
                  <div className="mt-2 space-y-2">
                    {hatchPopup.items.map((it,idx)=>(
                      <div key={idx} className="flex items-center justify-between rounded-xl p-3 bg-zinc-950/60 border border-zinc-800">
                        <div className="font-semibold">{it.rarity==="Nothing"?"Nothing":`${it.rarity} ${SKIN.name}`} <span className="text-xs text-zinc-500 ml-2">({it.box})</span></div>
                        <div className="text-sm">
                          {it.rarity==="Nothing" ? <span className="text-zinc-400">nothing</span> :
                            (it.autoDeleted ? <span className="text-amber-400">(auto-deleted +{fmt(it.refund)})</span> : <span className="text-emerald-400">kept</span>)}
                        </div>
                      </div>
                    ))}
                  </div>
                  <div className="mt-3 text-right">
                    <button className="btn btn-emerald px-4 py-2 rounded-xl" onClick={()=>setHatchPopup(null)}>Nice!</button>
                  </div>
                </div>
              </div>
            )}
          </div>
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(<App/>);

      <!-- test deploy -->  
    </script>
  </body>
</html>
